//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#import "LHUsersCategoriesExt.h"
#import "LHSettings.h"

@implementation LevelHelperLoader (USERS_CATEGORIES_EXTENSION)
////////////////////////////////////////////////////////////////////////////////
+(b2Body*) createFullScreenPhysicBoundaries:(b2World*)_world
{
    CGPoint wbConv = {1.0f, 1.0f};
    
    CGSize winSize = [[CCDirector sharedDirector] winSize];
	
    CGRect rect = {{0.0f, 0.0f}, {480.0f, 320.0f}};
	
    wbConv.x = winSize.width/rect.size.width;
    wbConv.y = winSize.height/rect.size.height;
    
    b2BodyDef bodyDef;	
	
	bodyDef.type = b2_staticBody;
	bodyDef.position.Set(0.0f, 0.0f);
    b2Body* body = _world->CreateBody(&bodyDef);
	
    
    {//TOP
        b2EdgeShape shape;
        
        b2Vec2 pos1 = b2Vec2(rect.origin.x/[[LHSettings sharedInstance] lhPtmRatio]*wbConv.x,
							 (winSize.height - rect.origin.y*wbConv.y)/[[LHSettings sharedInstance] lhPtmRatio]);
        
        b2Vec2 pos2 = b2Vec2((rect.origin.x + rect.size.width)*wbConv.x/[[LHSettings sharedInstance] lhPtmRatio], 
							 (winSize.height - rect.origin.y*wbConv.y)/[[LHSettings sharedInstance] lhPtmRatio]);
        
        
        shape.Set(pos1, pos2);		
        b2FixtureDef fixture;
        fixture.shape = &shape;
        fixture.isSensor = false;
        body->CreateFixture(&fixture);
    }
    
    {//LEFT
        b2EdgeShape shape;
        
		b2Vec2 pos1 = b2Vec2(rect.origin.x*wbConv.x/[[LHSettings sharedInstance] lhPtmRatio],
                          (winSize.height - rect.origin.y*wbConv.y)/[[LHSettings sharedInstance] lhPtmRatio]);
        
        b2Vec2 pos2 = b2Vec2((rect.origin.x*wbConv.x)/[[LHSettings sharedInstance] lhPtmRatio], 
                          (winSize.height - (rect.origin.y + rect.size.height)*wbConv.y)/[[LHSettings sharedInstance] lhPtmRatio]);
        
        
        shape.Set(pos1, pos2);		
        b2FixtureDef fixture;
        fixture.shape = &shape;
        body->CreateFixture(&fixture);
    }
    
    {//RIGHT
        b2EdgeShape shape;
        
        b2Vec2 pos1 = b2Vec2((rect.origin.x + rect.size.width)*wbConv.x/[[LHSettings sharedInstance] lhPtmRatio],
                          (winSize.height - rect.origin.y*wbConv.y)/[[LHSettings sharedInstance] lhPtmRatio]);
        
        b2Vec2 pos2 = b2Vec2((rect.origin.x+ rect.size.width)*wbConv.x/[[LHSettings sharedInstance] lhPtmRatio], 
                          (winSize.height - (rect.origin.y + rect.size.height)*wbConv.y)/[[LHSettings sharedInstance] lhPtmRatio]);
        
        
        shape.Set(pos1, pos2);		
        b2FixtureDef fixture;
        fixture.shape = &shape;
        body->CreateFixture(&fixture);
    }
    
    {//BOTTOM
        b2EdgeShape shape;
        
        b2Vec2 pos1 = b2Vec2(rect.origin.x*wbConv.x/[[LHSettings sharedInstance] lhPtmRatio],
                          (winSize.height - (rect.origin.y + rect.size.height)*wbConv.y)/[[LHSettings sharedInstance] lhPtmRatio]);
        
        b2Vec2 pos2 = b2Vec2((rect.origin.x+ rect.size.width)*wbConv.x/[[LHSettings sharedInstance] lhPtmRatio], 
                          (winSize.height - (rect.origin.y + rect.size.height)*wbConv.y)/[[LHSettings sharedInstance] lhPtmRatio]);
        
        
        shape.Set(pos1, pos2);	
        b2FixtureDef fixture;
        fixture.shape = &shape;
        fixture.isSensor = false;
        body->CreateFixture(&fixture);
    }
    
    return body;
}
////////////////////////////////////////////////////////////////////////////////
-(bool) isSprite:(LHSprite*)sprite atPoint:(CGPoint)point
{
    CGPoint position = [sprite position];
    CGSize size = [sprite contentSize];
    float scaleX = [sprite scaleX];
    float scaleY = [sprite scaleY];
    
    if((point.x > position.x - size.width*scaleX/2) &&
       (point.x < position.x + size.width*scaleX/2) &&
       (point.y > position.y - size.height*scaleY/2) &&
       (point.y < position.y + size.height*scaleY/2))
        return true;
    
    return false;
}

-(bool) isSpriteWithUniqueName:(NSString*)name atPoint:(CGPoint)point
{
    LHSprite* sprite = [self spriteWithUniqueName:name];
	
    if(nil == sprite)
        return false;
    
    return [self isSprite:sprite atPoint:point];
}
////////////////////////////////////////////////////////////////////////////////
-(void) replaceSpriteWithUniqueName:(NSString*)firstName 
        withNewSpriteWithUniqueName:(NSString*)secondName
{
    LHSprite* spr = [self spriteWithUniqueName:firstName];
    [self replaceSprite:spr withNewSpriteWithUniqueName:secondName];
}
////////////////////////////////////////////////////////////////////////////////
-(void) replaceSpriteForBody:(b2Body*)body 
 withNewSpriteWithUniqueName:(NSString*)desiredSpriteUniqueName
{
#ifndef LH_ARC_ENABLED
    LHSprite *spr = (LHSprite*)body->GetUserData();
#else
    LHSprite *spr = (__bridge LHSprite*)body->GetUserData();
#endif
    [self replaceSprite:spr withNewSpriteWithUniqueName:desiredSpriteUniqueName];
}
////////////////////////////////////////////////////////////////////////////////
-(void) replaceSprite:(LHSprite*)sprite withNewSpriteWithUniqueName:(NSString*)secondName
{
    if(sprite == nil)
        return;
    
    LHSprite* newSpr = [self spriteWithUniqueName:secondName];
    if(nil != newSpr)
    {
        [sprite setTexture:[newSpr texture]];
        #if COCOS2D_VERSION >= 0x00020000 
        if([sprite batchNode]){
        #else
        if([sprite usesBatchNode]){
        #endif
            [sprite setBatchNode:[newSpr batchNode]];
        }
        [sprite setTextureRect:[newSpr textureRect]];
    }
}

@end
