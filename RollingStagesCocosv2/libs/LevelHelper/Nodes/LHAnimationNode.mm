//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#import "LHAnimationNode.h"
#import "LevelHelperLoader.h"
#import "LHSettings.h"
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

@interface LHSprite (LH_ANIMATION_SPRITE_EXT_PRIVATE)
-(void) setAnimationSequence:(id)seq;
-(void) removeFromCocos2dParentNode:(BOOL)cleanup; //added in order to send ERROR message to user in the overloaded LHSprite removeFromParentAndCleanUp method
@end
@implementation LHSprite (LH_ANIMATION_SPRITE_EXT_PRIVATE)

-(void) setAnimationSequence:(id)seq{
    [self stopActionByTag:LH_ANIM_ACTION_TAG];
    [self runAction:seq];
}
-(void)removeFromCocos2dParentNode:(BOOL)cleanup
{
    [super removeFromParentAndCleanup:cleanup];
}
@end
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
@interface LHAnimationNode (Private)

@end
////////////////////////////////////////////////////////////////////////////////
@implementation LHAnimationNode
@synthesize loop;
@synthesize speed;
@synthesize repetitions;
@synthesize startAtLaunch;
////////////////////////////////////////////////////////////////////////////////
-(void) dealloc{		
    
    //NSLog(@"LH Animation Dealloc");
#ifndef LH_ARC_ENABLED
    [uniqueName release];
    [framesInfo release];
    [imageName release];
    [imageFolder release];
    [frames release];
	[super dealloc];
#endif
}
////////////////////////////////////////////////////////////////////////////////
-(id) initWithUniqueName:(NSString *)name{
    self = [super init];
    if (self != nil)
    {
        uniqueName = [[NSMutableString alloc] initWithString:name];
        imageName = [[NSMutableString alloc] init];
        frames = [[NSMutableArray alloc] init];
        framesInfo = [[NSMutableArray alloc] init];
        imageFolder = [[NSMutableString alloc] init];
        batchNode = nil;
        speed = 0.2f;
        repetitions = 1;
        loop = false;
    }
    return self;
}
////////////////////////////////////////////////////////////////////////////////
+(id) animationNodeWithUniqueName:(NSString*)name{
#ifndef LH_ARC_ENABLED
    return [[[self alloc] initWithUniqueName:name] autorelease];
#else
    return [[self alloc] initWithUniqueName:name];
#endif
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(void) setImageFolder:(NSString*)folder{
    [imageFolder setString:folder];
}
-(void) setUniqueName:(NSString*)name{
    NSAssert(name!=nil, @"UniqueName must not be nil");

    [uniqueName setString:name];
}
-(NSString*)uniqueName{
    return uniqueName;   
}
////////////////////////////////////////////////////////////////////////////////
-(NSString*)imageName{
    return imageName;
}
-(void) setImageName:(NSString*)image{
    [imageName setString:image];
}
////////////////////////////////////////////////////////////////////////////////
-(void)setFramesInfo:(NSArray*)frmInfo{
    [framesInfo removeAllObjects];
    [framesInfo addObjectsFromArray:frmInfo];
}
////////////////////////////////////////////////////////////////////////////////
-(void) computeFrames{
    
    if(batchNode == nil)
        return;
        
    NSMutableArray *ccframes = [NSMutableArray array];        
    for(NSDictionary* frm in framesInfo)
    {
        CGRect rect = LHRectFromString([frm objectForKey:@"FrameRect"]);
        
        NSString* image = [[LHSettings sharedInstance] imagePath:imageName imageFolder:imageFolder];

        if([[LHSettings sharedInstance] shouldScaleImageOnRetina:image]){
            rect.origin.x *=2.0f;
            rect.origin.y *=2.0f;
            rect.size.width *=2.0f;
            rect.size.height *=2.0f;
        }
                
        CCSpriteFrame* frame = [CCSpriteFrame frameWithTexture:[batchNode texture] 
                                                                rect:rect];
        [ccframes addObject:frame];      
    }

    [frames removeAllObjects];
    [frames addObjectsFromArray:ccframes];
}
////////////////////////////////////////////////////////////////////////////////
-(NSArray*)frames{
    return frames;
}
////////////////////////////////////////////////////////////////////////////////
-(void) setBatchNode:(CCSpriteBatchNode*)node{
    batchNode = node;
}
////////////////////////////////////////////////////////////////////////////////
-(void) runAnimationOnSprite:(LHSprite *)ccsprite 
           startingFromFrame:(int)startFrame 
             withNotifierObj:(id)animNotifierId 
                 notifierSel:(SEL)animNotifierSel 
                 notifOnLoop:(bool)notifOnLoop
{
    CCAnimate* animSeqFromStartAction = nil;
    
    if(startFrame > 0 && startFrame < (int)[frames count])
    {
        NSMutableArray* framesSeq = [[NSMutableArray alloc] init];
        
        for(int i = startFrame; i < (int)[frames count]; ++i){
            [framesSeq addObject:[frames objectAtIndex:i]];
        }
        
#if COCOS2D_VERSION >= 0x00020000
        CCAnimation *animSeqFromStartFrame = [CCAnimation animationWithSpriteFrames:framesSeq delay:speed];
        animSeqFromStartFrame = [CCAnimate actionWithAnimation:animSeqFromStartFrame];
#else
        CCAnimation *animSeqFromStartFrame = [CCAnimation animationWithFrames:framesSeq delay:speed];
        animSeqFromStartAction = [CCAnimate actionWithAnimation:animSeqFromStartFrame restoreOriginalFrame:NO];
#endif   
        

#ifndef LH_ARC_ENABLED
        [framesSeq release];
#endif
    }
    
#if COCOS2D_VERSION >= 0x00020000
    CCAnimation *anim = [CCAnimation animationWithSpriteFrames:frames delay:speed];
#else
    CCAnimation *anim = [CCAnimation animationWithFrames:frames delay:speed];
#endif
    
    CCFiniteTimeAction *seq;
    if(!loop)
    {
#if COCOS2D_VERSION >= 0x00020000
        id animAct = [CCRepeat actionWithAction:[CCAnimate actionWithAnimation:anim] 
                                          times:repetitions];
#else
        id animAct = [CCRepeat actionWithAction:[CCAnimate actionWithAnimation:anim 
                                                          restoreOriginalFrame:NO] 
                                          times:repetitions];
#endif
        
        id seq1 = animAct;
        if(animSeqFromStartAction != nil)
            seq1 = [CCSequence actionOne:animSeqFromStartAction two:animAct];

        
        if(nil != animNotifierId && nil != animNotifierSel)
        {
#ifndef LH_ARC_ENABLED
            id actionRestart = [CCCallFuncND actionWithTarget:animNotifierId 
                                                     selector:animNotifierSel 
                                                         data:uniqueName];
#else
            id actionRestart = [CCCallFuncND actionWithTarget:animNotifierId 
                                                     selector:animNotifierSel 
                                                         data:(__bridge void*)uniqueName];
#endif
                        
            seq = [CCSequence actionOne:seq1 two:actionRestart];
        }
        else
        {
            seq = [CCSequence actions:seq1, nil];
        }
    }
    else
    {
        if(notifOnLoop && nil != animNotifierId && nil != animNotifierSel)
        {
#ifndef LH_ARC_ENABLED
            id actionRestart = [CCCallFuncND actionWithTarget:animNotifierId 
                                                     selector:animNotifierSel 
                                                         data:uniqueName];
#else
            id actionRestart = [CCCallFuncND actionWithTarget:animNotifierId 
                                                     selector:animNotifierSel 
                                                         data:(__bridge void*)uniqueName];
#endif
            
#if COCOS2D_VERSION >= 0x00020000
            id animAct = [CCSequence actionOne:[CCAnimate actionWithAnimation:anim] 
                                           two:actionRestart];
#else
            id animAct = [CCSequence actionOne:[CCAnimate actionWithAnimation:anim 
                                                         restoreOriginalFrame:NO] 
                                           two:actionRestart];
#endif
            
            seq = [CCRepeatForever actionWithAction:animAct];
        }
        else
        {
#if COCOS2D_VERSION >= 0x00020000
            seq = [CCRepeatForever actionWithAction:[CCAnimate actionWithAnimation:anim]];
#else
            seq = [CCRepeatForever actionWithAction:[CCAnimate actionWithAnimation:anim 
                                                              restoreOriginalFrame:NO]];
#endif
        }
        
        if(animSeqFromStartAction != nil)
        {
            id repeatActionCantBeAddedInSequence = [CCCallFuncO actionWithTarget:ccsprite
                                                                        selector:@selector(setAnimationSequence:)
                                                                          object:seq];
            seq = [CCSequence actionOne:animSeqFromStartAction two:repeatActionCantBeAddedInSequence];
        }
    }
    
    [seq setTag:LH_ANIM_ACTION_TAG];
    
    if(seq != nil)
    {
        [ccsprite stopActionByTag:LH_ANIM_ACTION_TAG];
        [ccsprite setAnimation:self];
        [self setAnimationTexturePropertiesOnSprite:ccsprite];
        [ccsprite runAction:seq];    
    }
}
////////////////////////////////////////////////////////////////////////////////
-(int) numberOfFrames{
    return [frames count];
}
////////////////////////////////////////////////////////////////////////////////
-(void) setAnimationTexturePropertiesOnSprite:(LHSprite*)ccsprite
{
    if(![[LHSettings sharedInstance] isCoronaUser])
        [ccsprite removeFromCocos2dParentNode:YES];
    
    [ccsprite setTexture:[batchNode texture]];
    
    if(![[LHSettings sharedInstance] isCoronaUser])
    {
        [ccsprite setBatchNode:batchNode];
        [batchNode addChild:ccsprite];
    }
    
}
-(void) setFrame:(int)frameNo onSprite:(LHSprite*)spr{
    
    if(nil == spr)
        return;
    
    if(frameNo >= 0 && frameNo < (int)[frames count])
    {
        CCSpriteFrame* frame = [frames objectAtIndex:frameNo];
    
        if(nil != frame)
        {
            [spr setTextureRect:[frame rect]];
        }
    }
}
////////////////////////////////////////////////////////////////////////////////
@end
