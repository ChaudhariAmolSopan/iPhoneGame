//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////

#import "LHSettings.h"
#import "cocos2d.h"
#import "LevelHelperLoader.h"
@implementation LHSettings
////////////////////////////////////////////////////////////////////////////////

@synthesize useRetinaOnIpad;
@synthesize lhPtmRatio;
@synthesize customAlpha;
@synthesize convertLevel;
@synthesize levelPaused;
@synthesize isCoronaUser;
@synthesize preloadBatchNodes;
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
+ (LHSettings*)sharedInstance{
	static id sharedInstance = nil;
	if (sharedInstance == nil){
		sharedInstance = [[LHSettings alloc] init];
	}
    return sharedInstance;
}
////////////////////////////////////////////////////////////////////////////////
-(void)dealloc
{
#ifndef LH_ARC_ENABLED
	[imagesFolder release];
	[super dealloc];
#endif
}
////////////////////////////////////////////////////////////////////////////////
- (id)init
{
	self = [super init];
	if (self != nil) {
		useRetinaOnIpad = true;
		convertLevel = true;
		lhPtmRatio = 32.0f;
		customAlpha = 1.0f;
		convertRatio = CGPointMake(1, 1);
        realConvertRatio = CGPointMake(1, 1);
		newBodyId = 0;
        stretchArt = true;
        possitionOffset = CGPointMake(0.0f, 0.0f);
        levelPaused = false;
		imagesFolder = [[NSMutableString alloc] init];
        isCoronaUser = false;
        preloadBatchNodes = false;
	}
	return self;
}
////////////////////////////////////////////////////////////////////////////////}


-(int)newBodyId{
	return newBodyId++;
}

-(void) setImageFolder:(NSString*)img{
	if(img != nil)
		[imagesFolder setString:img];
}
-(NSString*)imageFolder{
	return imagesFolder;
}

-(NSString*)imagePath:(NSString*)file
{
    if([self isIpad])
    {   
        NSRange lastPt = [file rangeOfString:@"." options:NSBackwardsSearch];
        if(lastPt.location != NSNotFound)
        {
            NSString *newstring = [file stringByReplacingCharactersInRange:lastPt
                                                                withString:@"-hd."];
            
			
            NSString *fullpath = [CCFileUtils fullPathFromRelativePath:newstring];
			
			fullpath = [NSString stringWithFormat:@"%@%@", imagesFolder, fullpath];
			
            if([[NSFileManager defaultManager] fileExistsAtPath:fullpath])
            {
                return fullpath;
            }
            
			fullpath = [NSString stringWithFormat:@"%@%@", imagesFolder, file];
            return fullpath;
            
        }
        return [NSString stringWithFormat:@"%@%@", imagesFolder, file];
    }
    return [NSString stringWithFormat:@"%@%@", imagesFolder, file];
}
-(bool)shouldScaleImageOnRetina:(NSString*)image
{
    //if it contains -hd return true - else return false
    if(image == nil)
        return false;
    
    if ([image rangeOfString:@"-hd"].location == NSNotFound) {
        return false;
    } else {
        return true;
    }
        
    return false;
}

-(bool)isIpad
{
    if(![self useRetinaOnIpad]){
        return false;
    }
    
#ifndef __MAC_OS_X_VERSION_MAX_ALLOWED
	
    
#ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
#if __IPHONE_3_2 <= __IPHONE_OS_VERSION_MAX_ALLOWED
	UIDevice* thisDevice = [UIDevice currentDevice];
	if ([thisDevice respondsToSelector:@selector(userInterfaceIdiom)]){
		if(thisDevice.userInterfaceIdiom == UIUserInterfaceIdiomPad){
			return true;
		}
	}
	else{
		return false;
	}
#else
	return false;
#endif
    
#endif
    
#else
	return true;
#endif
	
	return false;
}

-(void) setStretchArt:(bool)value{
    stretchArt = value;
    possitionOffset.x =0.0f;
    possitionOffset.y =0.0f;   
}

-(void) setConvertRatio:(CGPoint)val{
	convertRatio = val;
    realConvertRatio = val;
    if(!stretchArt)
    {
        if([self isIpad])
        {
            if(convertRatio.x > 1.0 || convertRatio.y > 1.0f)
            {
                convertRatio.x = 2.0f;
                convertRatio.y = 2.0f;
                
#ifdef LH_SCENE_TESTER
    convertRatio.x = 1.0f;
    convertRatio.y = 1.0f;
#endif
                
                if([[CCDirector sharedDirector] winSize].width == 1024.0f)
                {
                    possitionOffset.x = 32.0f;
                    possitionOffset.y = 64.0f;   
                }
                else {
                    possitionOffset.x = 64.0f;
                    possitionOffset.y = 32.0f;
                }
                
#ifdef LH_SCENE_TESTER
                if([[CCDirector sharedDirector] winSize].width == 512.0f)
                {
                    possitionOffset.x = 16.0f;
                    possitionOffset.y = 32.0f;  
                }
                else {
                    possitionOffset.x = 32.0f;
                    possitionOffset.y = 16.0f;
                }
#endif

            }
        }
    }
}
-(CGPoint) possitionOffset{
    return possitionOffset;
}

-(CGPoint) convertRatio{
	
	if(!convertLevel)
		return CGPointMake(1, 1);
	
	return convertRatio;
}


-(CGPoint) realConvertRatio{
    if(!convertLevel)
		return CGPointMake(1, 1);
	
	return realConvertRatio;
}


@end
