//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#import "LHBezierNode.h"
#import "LevelHelperLoader.h"
#import "LHTouchMgr.h"
#import "LHPathNode.h"
#import "LHSettings.h"
#import "LHSprite.h"
#import <Availability.h>

#ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
#import <OpenGLES/EAGL.h>
#elif defined(__MAC_OS_X_VERSION_MAX_ALLOWED)
#import <OpenGL/OpenGL.h>
#endif

@interface LHBezierBlendingInfo : NSObject
{
    CCTexture2D* texture;
    GLenum blendSource;
    GLenum blendDestination;
    bool tile;
}

+(id) bezierBlendingInfoWithTexture:(CCTexture2D*)tex
                        blendSource:(GLenum)source
                   blendDestination:(GLenum)destination
                               tile:(bool)shouldTile;

-(id) initBezierBlendingInfoWithTexture:(CCTexture2D*)tex
                            blendSource:(GLenum)source
                       blendDestination:(GLenum)destination
                                   tile:(bool)shouldTile;

-(CCTexture2D*) texture;
-(GLenum) blendSource;
-(GLenum) blendDestination;
-(bool) tile;
@end
//------------------------------------------------------------------------------
@implementation LHBezierBlendingInfo
-(void) dealloc{
#ifndef LH_ARC_ENABLED
	[super dealloc];
#endif
}
+(id) bezierBlendingInfoWithTexture:(CCTexture2D*)tex
                        blendSource:(GLenum)source
                   blendDestination:(GLenum)destination
                               tile:(bool)shouldTile;
{
#ifndef LH_ARC_ENABLED
	return [[[self alloc] initBezierBlendingInfoWithTexture:tex
                                                blendSource:source
                                           blendDestination:destination
                                                       tile:shouldTile] autorelease];
#else
    return [[self alloc] initBezierBlendingInfoWithTexture:tex
                                                blendSource:source
                                           blendDestination:destination
                                                       tile:shouldTile];
#endif
}
-(id) initBezierBlendingInfoWithTexture:(CCTexture2D*)tex
                            blendSource:(GLenum)source
                       blendDestination:(GLenum)destination
                                   tile:(bool)shouldTile{
	if( (self=[super init])) {
        texture = tex;
        blendSource = source;
        blendDestination = destination;
        tile = shouldTile;
	}
	return self;
}

-(CCTexture2D*) texture{return texture;}
-(GLenum) blendSource{return blendSource;}
-(GLenum) blendDestination{return blendDestination;}
-(bool) tile{return tile;}

@end


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
@interface LHBezierNode (Private)

@end
////////////////////////////////////////////////////////////////////////////////
@implementation LHBezierNode
@synthesize isClosed;
@synthesize isTile;
@synthesize isVisible;
@synthesize isLine;
@synthesize swallowTouches;
////////////////////////////////////////////////////////////////////////////////
-(void) dealloc{		

#ifndef LH_ARC_ENABLED
    if(touchBeginObserver)
        [touchBeginObserver release];
    if(touchBeginObserver)
        [touchMovedObserver release];
    if(touchBeginObserver)
        [touchEndedObserver release];
#endif
    
	if(NULL != body)
	{
		b2World* _world = body->GetWorld();
		if(0 != _world)
		{
			_world->DestroyBody(body);
			body = NULL;
		}
	}
#ifndef LH_ARC_ENABLED    
    [blendingTextures release];
	[uniqueName release];	
	[pathPoints release];
	[linesHolder release];
	[trianglesHolder release];

	[super dealloc];
#endif
}
////////////////////////////////////////////////////////////////////////////////
+(CGPoint) pointOnCurve:(CGPoint) p1 p2:(CGPoint)p2 p3:(CGPoint)p3 p4:(CGPoint)p4 t:(float)t
{
	float var1, var2, var3;
    CGPoint vPoint = {0.0f, 0.0f};
    
    var1 = 1 - t;
    var2 = var1 * var1 * var1;
    var3 = t * t * t;
    vPoint.x = var2*p1.x + 3*t*var1*var1*p2.x + 3*t*t*var1*p3.x + var3*p4.x;
    vPoint.y = var2*p1.y + 3*t*var1*var1*p2.y + 3*t*t*var1*p3.y + var3*p4.y;
    return(vPoint);				
}
////////////////////////////////////////////////////////////////////////////////
-(void) initTileVerticesFromDictionary:(NSDictionary*)bezierDict
{
	trianglesHolder = [[NSMutableArray alloc] init];

    float scale = 1;
    #ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
        scale = [[CCDirector sharedDirector] contentScaleFactor];
    #endif


    
	CGPoint convert = [[LHSettings sharedInstance] convertRatio];
	NSArray* fixtures = [bezierDict objectForKey:@"TileVertices"];
	for(NSArray* fix in fixtures)
	{
		NSMutableArray* triangle = [[NSMutableArray alloc] init];
		for(NSString* pt in fix)
		{
			CGPoint point = LHPointFromString(pt);
			
            CGPoint pos_offset = [[LHSettings sharedInstance] possitionOffset];
            //point.x += pos_offset.x;
            //point.y += pos_offset.y;
            
			point.x = point.x* convert.x;
			point.y = winSize.height - point.y*convert.y;
            
            point.x += pos_offset.x;
            point.y -= pos_offset.y;
            
			[triangle addObject:LHValueWithCGPoint(point)];
		}
		
		[trianglesHolder addObject:triangle];
#ifndef LH_ARC_ENABLED
		[triangle release];
#endif
	}	
	
	
	linesHolder = [[NSMutableArray alloc] init];
	if(isVisible)
	{
		NSArray* curvesInShape = [bezierDict objectForKey:@"Curves"];
		
		int MAX_STEPS = 25;
		
		for(NSDictionary* curvDict in curvesInShape)
		{
			CGPoint endCtrlPt   = LHPointFromString([curvDict objectForKey:@"EndControlPoint"]);
			CGPoint startCtrlPt = LHPointFromString([curvDict objectForKey:@"StartControlPoint"]);
			CGPoint endPt       = LHPointFromString([curvDict objectForKey:@"EndPoint"]);
			CGPoint startPt     = LHPointFromString([curvDict objectForKey:@"StartPoint"]);
			
            CGPoint pos_offset = [[LHSettings sharedInstance] possitionOffset];
                        
			if(!isLine)
			{
				CGPoint prevPoint;
				bool firstPt = true;
				
				for(float t = 0; t <= (1 + (1.0f / MAX_STEPS)); t += 1.0f / MAX_STEPS)
				{
					CGPoint vPoint = [LHBezierNode pointOnCurve:startPt
															 p2:startCtrlPt
															 p3:endCtrlPt
															 p4:endPt
															  t:t];
					
					if(!firstPt)
					{
						CGPoint pt1 = CGPointMake(prevPoint.x*convert.x, 
												  winSize.height - prevPoint.y*convert.y);
						CGPoint pt2 = CGPointMake(vPoint.x*convert.x, 
												  winSize.height - vPoint.y*convert.y);
						
                        pt1.x *= scale;
                        pt1.y *= scale;

                        pt2.x *= scale;
                        pt2.y *= scale;
                        
                        pt1.x += pos_offset.x;
                        pt1.y -= pos_offset.y;
                        
                        pt2.x += pos_offset.x;
                        pt2.y -= pos_offset.y;
                        
						[linesHolder addObject:LHValueWithCGPoint(pt1)];
						[linesHolder addObject:LHValueWithCGPoint(pt2)];
					}
					prevPoint = vPoint;
					firstPt = false;					
				}
			}
			else
			{
				
				CGPoint pos1 = CGPointMake(startPt.x*convert.x, 
										   winSize.height - startPt.y*convert.y);
				CGPoint pos2 = CGPointMake(endPt.x*convert.x, 
										   winSize.height - endPt.y*convert.y);
				
                pos1.x *= scale;
                pos1.y *= scale;
                
                pos2.x *= scale;
                pos2.y *= scale;
                
                pos1.x += pos_offset.x;
                pos1.y -= pos_offset.y;
                
                pos2.x += pos_offset.x;
                pos2.y -= pos_offset.y;

				[linesHolder addObject:LHValueWithCGPoint(pos1)];
				[linesHolder addObject:LHValueWithCGPoint(pos2)];
				
			}
		}
	}
}
////////////////////////////////////////////////////////////////////////////////
-(void) initPathPointsFromDictionary:(NSDictionary*)bezierDict
{
	pathPoints = [[NSMutableArray alloc] init];
	
    NSArray* curvesInShape = [bezierDict objectForKey:@"Curves"];    
    int MAX_STEPS = 25;    
	CGPoint conv = [[LHSettings sharedInstance] convertRatio];
	int i = 0;
    for(NSDictionary* curvDict in curvesInShape)
    {
        CGPoint endCtrlPt   = LHPointFromString([curvDict objectForKey:@"EndControlPoint"]);
        CGPoint startCtrlPt = LHPointFromString([curvDict objectForKey:@"StartControlPoint"]);
        CGPoint endPt       = LHPointFromString([curvDict objectForKey:@"EndPoint"]);
        CGPoint startPt     = LHPointFromString([curvDict objectForKey:@"StartPoint"]);
		
		CGPoint pos_offset = [[LHSettings sharedInstance] possitionOffset];
        
		if(!isLine)
        {
            for(float t = 0; t <= (1 + (1.0f / MAX_STEPS)); t += 1.0f / MAX_STEPS)
            {
                CGPoint vPoint = [LHBezierNode pointOnCurve:startPt
														 p2:startCtrlPt
														 p3:endCtrlPt
														 p4:endPt
														  t:t];
				vPoint = LHMakePoint(vPoint.x*conv.x, 
                                     winSize.height - vPoint.y*conv.y);

                vPoint.x += pos_offset.x;
                vPoint.y -= pos_offset.y;
                
                [pathPoints addObject:LHValueWithCGPoint(vPoint)];
            }
			
			[pathPoints removeLastObject];
        }
        else
        {
            CGPoint sPoint = LHMakePoint(startPt.x*conv.x, 
                                 winSize.height - startPt.y*conv.y);
            
            sPoint.x += pos_offset.x;
            sPoint.y -= pos_offset.y;
            
            [pathPoints addObject:LHValueWithCGPoint(sPoint)];            
            
            if(i == (int)[curvesInShape count]-1)
            {
                CGPoint ePoint = LHMakePoint(endPt.x*conv.x, 
                                             winSize.height - endPt.y*conv.y);
                
                ePoint.x += pos_offset.x;
                ePoint.y -= pos_offset.y;
                
                [pathPoints addObject:LHValueWithCGPoint(ePoint)]; 
            }
            ++i;            
        }
	}	
	
}
////////////////////////////////////////////////////////////////////////////////
-(void) createBodyFromDictionary:(NSDictionary*)bezierDict physicWorld:(b2World*)world
{
	if(isPath)
		return;
	
	if([pathPoints count] < 2)
		return;
	
	b2BodyDef bodyDef;	
	
	int bodyType = [[bezierDict objectForKey:@"PhysicType"] intValue];
	if(bodyType > 2)
        return;
        
	bodyDef.type = (b2BodyType)bodyType;
    
	bodyDef.position.Set(0.0f, 0.0f);
	bodyDef.angle = 0.0f;
	
#ifndef LH_ARC_ENABLED
	bodyDef.userData = self;
#else
    bodyDef.userData = (__bridge void*)self;
#endif
	
	body = world->CreateBody(&bodyDef);
	
  
	float ptm = [[LHSettings sharedInstance] lhPtmRatio];

    for(NSArray* fix in trianglesHolder)
    {
        int size = [fix count];
        b2Vec2 *verts = new b2Vec2[size];
        int i = 0;
        for(int j = (int)[fix count]-1; j >=0; --j)
        {
            NSValue* val = [fix objectAtIndex:j];
                        
            CGPoint pt = LHPointFromValue(val);
            
            verts[i].x = pt.x/ptm;
            verts[i].y = pt.y/ptm;            
            ++i;
        }

        b2PolygonShape shape;
        shape.Set(verts, size);		
        
        b2FixtureDef fixture;
        
        fixture.density = [[bezierDict objectForKey:@"Density"] floatValue];
		fixture.friction = [[bezierDict objectForKey:@"Friction"] floatValue];
		fixture.restitution = [[bezierDict objectForKey:@"Restitution"] floatValue];
		
		fixture.filter.categoryBits = [[bezierDict objectForKey:@"Category"] intValue];
		fixture.filter.maskBits = [[bezierDict objectForKey:@"Mask"] intValue];
		fixture.filter.groupIndex = [[bezierDict objectForKey:@"Group"] intValue];
		
		fixture.isSensor = [[bezierDict objectForKey:@"IsSenzor"] boolValue];
        
        fixture.shape = &shape;
        body->CreateFixture(&fixture);
        delete[] verts;
    }		
    
    if([pathPoints count] > 0)
    {
    
        b2Vec2 * verts = new b2Vec2 [(int)[pathPoints count]];

        int i = 0;
        for(NSValue* val in pathPoints)
        {
            CGPoint pt = LHPointFromValue(val);
            verts [i]. x = pt.x / ptm;
            verts [i]. y = pt.y / ptm;
            ++i;
        }
        b2ChainShape shape;
        shape.CreateChain (verts, (int)[pathPoints count]);
    
        b2FixtureDef fixture;
    
    
        fixture.density = [[bezierDict objectForKey:@"Density"] floatValue];
        fixture.friction = [[bezierDict objectForKey:@"Friction"] floatValue];
        fixture.restitution = [[bezierDict objectForKey:@"Restitution"] floatValue];
    
        fixture.filter.categoryBits = [[bezierDict objectForKey:@"Category"] intValue];
        fixture.filter.maskBits = [[bezierDict objectForKey:@"Mask"] intValue];
        fixture.filter.groupIndex = [[bezierDict objectForKey:@"Group"] intValue];
    
        fixture.isSensor = [[bezierDict objectForKey:@"IsSenzor"] boolValue];

        fixture.shape = &shape;
        body-> CreateFixture (& fixture);
        delete [] verts;
    }   
}
////////////////////////////////////////////////////////////////////////////////
-(id) initWithDictionary:(NSDictionary*)bezierDict 
			  cocosLayer:(CCLayer*)ccLayer
			 physicWorld:(b2World*)world
                  parent:(LevelHelperLoader*)parent
{
	self = [super init];
	if (self != nil)
	{
		isClosed	= [[bezierDict objectForKey:@"IsClosed"] boolValue];
		isTile		= [[bezierDict objectForKey:@"IsTile"] boolValue];
		isVisible	= [[bezierDict objectForKey:@"IsDrawable"] boolValue];
		isLine		= [[bezierDict objectForKey:@"IsSimpleLine"] boolValue];
		isPath		= [[bezierDict objectForKey:@"IsPath"] boolValue];
		
		uniqueName = [[NSString alloc] initWithString:[bezierDict objectForKey:@"UniqueName"]];
		
        parentLoader = parent;
                
        blendingTextures = [[NSMutableArray alloc] init];
		// pathNodes = [[NSMutableSet alloc] init];
		
		[self setTag:[[bezierDict objectForKey:@"Tag"] intValue]];
		[self setVertexZ:[[bezierDict objectForKey:@"ZOrder"] intValue]];
		
		NSString* img = [bezierDict objectForKey:@"Image"];
		imageSize = CGSizeZero;
		if(![img isEqualToString:@""])
		{
			NSString* path = [[LHSettings sharedInstance] imagePath:img];
			texture = [[CCTextureCache sharedTextureCache] addImage:path];
			if( texture ) {
				imageSize = texture.contentSize;
			}
		}
		
		//CGPoint convert = [[LHSettings sharedInstance] convertRatio];
		winSize = [[CCDirector sharedDirector] winSize];		
		
		
		color = CCRectFromString([bezierDict objectForKey:@"Color"]);
		lineColor = CCRectFromString([bezierDict objectForKey:@"LineColor"]);
		lineWidth = [[bezierDict objectForKey:@"LineWidth"] floatValue];
    
		[self initTileVerticesFromDictionary:bezierDict];
		
		[self initPathPointsFromDictionary:bezierDict];	
		
		[self createBodyFromDictionary:bezierDict physicWorld:world];
        
        
        touchBeginObserver = nil;
        touchMovedObserver = nil;
        touchEndedObserver = nil;
        
        tagTouchBeginObserver = nil;
        tagTouchMovedObserver = nil;
        tagTouchEndedObserver = nil;
	}
	return self;
}
////////////////////////////////////////////////////////////////////////////////
+(id) nodeWithDictionary:(NSDictionary*)properties 
			  cocosLayer:(CCLayer*)ccLayer
			 physicWorld:(b2World*)world
                  parent:(LevelHelperLoader*)parent
{
#ifndef LH_ARC_ENABLED
	return [[[self alloc] initWithDictionary:properties 
								  cocosLayer:ccLayer 
								 physicWorld:world
                                      parent:parent] autorelease];
#else
    return [[self alloc] initWithDictionary:properties 
								  cocosLayer:ccLayer 
								 physicWorld:world
                                      parent:parent];
#endif
}
////////////////////////////////////////////////////////////////////////////////
-(NSString*)uniqueName{
    return uniqueName;
}
////////////////////////////////////////////////////////////////////////////////
-(b2Body*)body{
    return body;
}
////////////////////////////////////////////////////////////////////////////////
-(void)visit
{
	[super visit];
}
////////////////////////////////////////////////////////////////////////////////
-(void)draw
{
	if(0.0f != [[LHSettings sharedInstance] customAlpha])
	{
		glColor4f(color.origin.x, 
				  color.origin.y, 
				  color.size.width, 
				  color.size.height*[[LHSettings sharedInstance] customAlpha]);
		glPushMatrix();
		
        glDisableClientState(GL_COLOR_ARRAY);
        
		glEnable(GL_TEXTURE_2D);		
		glBindTexture(GL_TEXTURE_2D, texture.name);
		
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
		
        float scale = 1;
        #ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
            scale = [[CCDirector sharedDirector] contentScaleFactor];
        #endif

        int size = [trianglesHolder count];
        CGPoint* glVertices = new CGPoint[size*3];
        CGPoint* glUV = new CGPoint[size*3];
        for(int k = 0; k < (int)[trianglesHolder count]; ++k)
        {
            NSArray* fix = [trianglesHolder objectAtIndex:k];
        
            for(int j = 0; j < 3; ++j)
			{
                NSValue* val  = [fix objectAtIndex:j];
                                
				CGPoint pt = LHPointFromValue(val);
                
                pt.x *=scale;
                pt.y *=scale;
				glVertices[k*3 +j] =pt;
				
				glUV[k*3+j].x = (pt.x/imageSize.width);
				glUV[k*3+j].y = ((winSize.height - pt.y)/imageSize.height);
			}
        }
        glTexCoordPointer(2, GL_FLOAT, 0, glUV);
        glVertexPointer(2, GL_FLOAT, 0, glVertices);
        glDrawArrays(GL_TRIANGLES, 0, 3*size);
        
        
        bool wasBlend = glIsEnabled(GL_BLEND);
        glEnable(GL_BLEND);            
        int oldBlendDST = 0;
        glGetIntegerv(GL_BLEND_DST, &oldBlendDST);
        int oldBlendSRC = 0;
        glGetIntegerv(GL_BLEND_SRC, &oldBlendSRC);
        
        for(LHBezierBlendingInfo* info in blendingTextures)
        {
            CCTexture2D* tex = [info texture];
            if(NULL != tex)
            {
                glBlendFunc([info blendSource], [info blendDestination]);
                glBindTexture(GL_TEXTURE_2D, [tex name]);
                
                if([info tile]){
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
                    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
                }
                
                glTexCoordPointer(2, GL_FLOAT, 0, glUV);
                glVertexPointer(2, GL_FLOAT, 0, glVertices);
                glDrawArrays(GL_TRIANGLES, 0, 3*size);                
            }
        }
        
        glBlendFunc(oldBlendSRC, oldBlendDST);
        if(!wasBlend)
            glDisable(GL_BLEND);
        
        
        delete[] glVertices;
        delete[] glUV;
        
        
        float oldLineWidth = 1.0f;
		glGetFloatv(GL_LINE_WIDTH, &oldLineWidth); 
		
		glLineWidth(lineWidth);
		
		glDisable(GL_TEXTURE_2D);
        glDisableClientState(GL_TEXTURE_COORD_ARRAY);
		glColor4f(lineColor.origin.x, 
				  lineColor.origin.y, 
				  lineColor.size.width, 
				  lineColor.size.height*[[LHSettings sharedInstance] customAlpha]);
		
        CGPoint* line_verts = new CGPoint[[linesHolder count]];
        for(int i = 0; i < (int)[linesHolder count]; i+=2)
		{
            CGPoint pt1 = LHPointFromValue([linesHolder objectAtIndex:i]);
			CGPoint pt2 = LHPointFromValue([linesHolder objectAtIndex:i+1]);
            
            line_verts[i] = pt1;
            line_verts[i+1] = pt2;            
		}
        glVertexPointer(2, GL_FLOAT, 0, line_verts);
        glDrawArrays(GL_LINES, 0, [linesHolder count]);
        delete[] line_verts;
        
        glEnableClientState(GL_TEXTURE_COORD_ARRAY);
        glEnableClientState(GL_COLOR_ARRAY);
		glLineWidth(oldLineWidth);
		glEnable(GL_TEXTURE_2D);	
		glPopMatrix();
	}	
}
////////////////////////////////////////////////////////////////////////////////
-(LHPathNode*)addSpriteOnPath:(LHSprite*)spr
                        speed:(float)pathSpeed 
              startAtEndPoint:(bool)startAtEndPoint
                     isCyclic:(bool)isCyclic
            restartAtOtherEnd:(bool)restartOtherEnd
              axisOrientation:(int)axis
                        flipX:(bool)flipx
                        flipY:(bool)flipy
                deltaMovement:(bool)dMove;
{
	
	LHPathNode* node = [LHPathNode nodePathWithPoints:pathPoints];	
    [node setStartAtEndPoint:startAtEndPoint];
	[node setSprite:spr];
	[node setBody:[spr body]];
    
    if(!dMove){
       if([pathPoints count] > 0)
       {
           CGPoint pathPos = LHPointFromValue([pathPoints objectAtIndex:0]);
           [spr transformPosition:pathPos];
       }
    }
    
	[node setSpeed:pathSpeed];
    [node setRestartOtherEnd:restartOtherEnd];
	node.isCyclic = isCyclic;
	node.axisOrientation = axis;
	node.isLine = isLine;
    node.flipX = flipx;
    node.flipY = flipy;
    [node setUniqueName:uniqueName];
	//[pathNodes addObject:node];
	
	[self.parent addChild:node];
    
    return  node;
}
////////////////////////////////////////////////////////////////////////////////
-(void) pushBlendingTextureNamed:(NSString*) texName
                      shouldTile:(bool)tile
                  blendingSource:(GLenum)blendSource
             blendingDestination:(GLenum)blendDestination{
    
    
    if(!isTile)
        return;
    
    CCTexture2D* tex = [[CCTextureCache sharedTextureCache] addImage:texName];
    if(NULL != tex){
        LHBezierBlendingInfo* info = [LHBezierBlendingInfo bezierBlendingInfoWithTexture:tex 
                                                                             blendSource:blendSource 
                                                                        blendDestination:blendDestination
                                                                                    tile:tile];
        [blendingTextures addObject:info];
    }
}
//------------------------------------------------------------------------------
-(void) pushBlendingTextureNamed:(NSString*) texName
                      shouldTile:(bool)tile{

    [self pushBlendingTextureNamed:texName
                        shouldTile:tile
                    blendingSource:GL_DST_COLOR
               blendingDestination:GL_ZERO];
}
//------------------------------------------------------------------------------
-(void) pushBlendingTextureNamed:(NSString*) texName{    
    [self pushBlendingTextureNamed:texName
                        shouldTile:YES
                    blendingSource:GL_DST_COLOR
               blendingDestination:GL_ZERO];
}
////////////////////////////////////////////////////////////////////////////////
+(bool) isLHBezierNode:(id)object{
    if([object isKindOfClass:[LHBezierNode class]]){
        return true;
    }
    return false;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(bool)isTouchedAtPoint:(CGPoint)point{
    if(body != NULL)
    {
        b2Fixture* stFix = body->GetFixtureList();
        while(stFix != 0){
            if(stFix->TestPoint(b2Vec2(point.x/[[LHSettings sharedInstance] lhPtmRatio], 
                                       point.y/[[LHSettings sharedInstance] lhPtmRatio]))){
                return true;
            }
            stFix = stFix->GetNext();
        }
    }
    return false;    
}
//------------------------------------------------------------------------------
-(void)registerTouchBeginObserver:(id)observer selector:(SEL)selector{
    if(!isTile){
        CCLOG(@"Touch Events on bezier objects can only be performed on Tiled Shapes beziers. Touch Event Will be ignored.");
        return;
    }

    if(nil == touchBeginObserver)
        touchBeginObserver = [LHObserverPair observerPair];
    
    touchBeginObserver.object = observer;
    touchBeginObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [touchBeginObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerTouchMovedObserver:(id)observer selector:(SEL)selector{
    if(!isTile){
        CCLOG(@"Touch Events on bezier objects can only be performed on Tiled Shapes beziers. Touch Event Will be ignored.");
        return;
    }

    if(nil == touchMovedObserver)
        touchMovedObserver = [LHObserverPair observerPair];
    
    touchMovedObserver.object = observer;
    touchMovedObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [touchMovedObserver retain];    
#endif
}
//------------------------------------------------------------------------------
-(void)registerTouchEndedObserver:(id)observer selector:(SEL)selector{

    if(!isTile){
        CCLOG(@"Touch Events on bezier objects can only be performed on Tiled Shapes beziers. Touch Event Will be ignored.");
        return;
    }
    
    if(nil == touchEndedObserver)
        touchEndedObserver = [LHObserverPair observerPair];
    
    touchEndedObserver.object = observer;
    touchEndedObserver.selector = selector; 
#ifndef LH_ARC_ENABLED
    [touchEndedObserver retain];
#endif
}
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#ifdef __MAC_OS_X_VERSION_MAX_ALLOWED
//for left mouse events use the touch observers from above 
-(void)registerRightMouseDownObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseDownObserver)
        rightMouseDownObserver = [LHObserverPair observerPair];
    
    rightMouseDownObserver.object = observer;
    rightMouseDownObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseDownObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerRightMouseDraggedObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseDraggedObserver)
        rightMouseDraggedObserver = [LHObserverPair observerPair];
    
    rightMouseDraggedObserver.object = observer;
    rightMouseDraggedObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseDraggedObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerRightMouseUpObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseUpObserver)
        rightMouseUpObserver = [LHObserverPair observerPair];
    
    rightMouseUpObserver.object = observer;
    rightMouseUpObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseUpObserver retain];
#endif    
}
#endif
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
- (BOOL)ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event{
    CGPoint touchPoint = [touch locationInView:[touch view]];    
    touchPoint=  [[CCDirector sharedDirector] convertToGL:touchPoint];    

    
    if([self isTouchedAtPoint:touchPoint])
    {
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = touch;
        info.bezier = self;
        info.delta = CGPointZero;

        [LHObserverPair performObserverPair:touchBeginObserver object:info];
        [LHObserverPair performObserverPair:tagTouchBeginObserver object:info]; 

        return swallowTouches;
    }
    return NO;
}
//------------------------------------------------------------------------------
- (void)ccTouchMoved:(UITouch *)touch withEvent:(UIEvent *)event{    
    CGPoint touchPoint = [touch locationInView:[touch view]];
    touchPoint=  [[CCDirector sharedDirector] convertToGL:touchPoint];
    
    CGPoint prevLocation = [touch previousLocationInView:[touch view]];
    prevLocation = [[CCDirector sharedDirector] convertToGL:prevLocation];    
    
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = touch;
    info.delta = CGPointMake(touchPoint.x - prevLocation.x,
                             touchPoint.y - prevLocation.y);
    info.bezier = self;
    
    [LHObserverPair performObserverPair:touchMovedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchMovedObserver object:info];     
}
//------------------------------------------------------------------------------
- (void)ccTouchEnded:(UITouch *)touch withEvent:(UIEvent *)event{
    
    CGPoint touchPoint = [touch locationInView:[touch view]];
    touchPoint=  [[CCDirector sharedDirector] convertToGL:touchPoint];

    CGPoint prevLocation = [touch previousLocationInView:[touch view]];
    prevLocation = [[CCDirector sharedDirector] convertToGL:prevLocation];    

    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = touch;
    info.bezier = self;
    info.delta = CGPointMake(touchPoint.x - prevLocation.x,
                             touchPoint.y - prevLocation.y);

    [LHObserverPair performObserverPair:touchEndedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchEndedObserver object:info];         
}
//------------------------------------------------------------------------------
#elif defined(__MAC_OS_X_VERSION_MAX_ALLOWED)
//------------------------------------------------------------------------------
-(BOOL) ccMouseDown:(NSEvent*)event{   
    
    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    
    if([self isTouchedAtPoint:touchPoint])
    {
        mouseDownStarted = true;
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = nil;
        info.bezier = self;
        info.delta = CGPointZero;
        
        [LHObserverPair performObserverPair:touchBeginObserver object:info];
        [LHObserverPair performObserverPair:tagTouchBeginObserver object:info]; 
        
        return swallowTouches;
    }
    return NO;//propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccMouseDragged:(NSEvent*)event{
    
    if(!mouseDownStarted)
        return NO;

    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
            
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.bezier = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:touchMovedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchMovedObserver object:info]; 
    
    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccMouseUp:(NSEvent*)event{
    
    if(!mouseDownStarted)
        return NO;

    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    
    mouseDownStarted = false;
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.bezier = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:touchEndedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchEndedObserver object:info]; 
    
    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseDown:(NSEvent*)event{
    
    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    
    if([self isTouchedAtPoint:touchPoint])
    {
        r_mouseDownStarted = true;
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = nil;
        info.bezier = self;
        info.delta = CGPointZero;
        
        [LHObserverPair performObserverPair:rightMouseDownObserver object:info];
        [LHObserverPair performObserverPair:tagRightMouseDownObserver object:info]; 
        
        return swallowTouches;
    }
    return NO;//propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseDragged:(NSEvent*)event{
    
    if(!r_mouseDownStarted)
        return NO;

    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.bezier = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:rightMouseDraggedObserver object:info];
    [LHObserverPair performObserverPair:tagRightMouseDraggedObserver object:info]; 
    
    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseUp:(NSEvent*)event{
    
    if(!r_mouseDownStarted)
        return NO;
    
    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    r_mouseDownStarted = false;
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.bezier = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:rightMouseUpObserver object:info];
    [LHObserverPair performObserverPair:tagRightMouseUpObserver object:info]; 
    
    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
#endif //touch events on mac
//------------------------------------------------------------------------------

@end
